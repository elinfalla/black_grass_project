---
title: "Farmland Biodiversity Health Index - <br> Butterfly and Bee Risk Scores"
author: "Elin Falla"
output:
  html_document: default
  pdf_document: default
  word_document: default
fontsize: 11pt
---
```{r setup, include=FALSE, purl=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1. Introduction  
This script calculates risk scores associated with changes to farm management, for **butterfly** and/or **bee** species reliant on farmland. **The user decides which scores to calculate by setting the input variable to 'butterflies', 'bees' or 'both'.**

**Note:** the script needs at least 2 species inputted to run.

The method is from **Butler, S. J. et al.** 'A cross-taxonomic index for quantifying the health of farmland biodiversity.' J. Appl. Ecol. 46, 1154-1162 (2009) https://doi.org/10.1111/j.1365-2664.2009.01709.x  

This risk assessment framework assumes that the major mechanisms of impact on UK farmland bees and butterflies will be:  
1. reduced forage plant abundance ($P$)   
2. reduced foraging activity due to loss of habitat ($F$)  
3. reduced nesting success ($N$) - **BEES ONLY**

The method calculates risk based on the overlaps between the resource requirements used by each species and the resource requirements affected by the change.

-----

### 1.1. Risk score equation - butterflies

The risk score is calculated as follows:  
$$ Risk Score = \frac{P_{ta} + F_{ta}}{R_a} + \frac{P_{tl} + F_{tl}}{R_l} $$

where subscript $l$ refers to larvae and subscript $a$ refers to adults. The risk score is hence the sum of the risk scores for the adult and larval stage for a particular species, where:  
$P_t$ = the risk score associated with reduced foraging activity potential  
$F_t$ = the risk score associated with reduction in forage plant availability  
$R$ = the species’ reliance on farmland habitat  

&nbsp;  

### 1.2. Risk score equation - bees

The risk score is calculated as follows: 

$$Risk Score = \frac{(P_t + F_t + N_t)} {R}$$  
where:  
$P_t$ = the risk score associated with reduced foraging activity potential  
$F_t$ = the risk score associated with reduction in forage plant availability  
$N_t$ = the risk score associated with reduced nest site availability  
$R$ = the species’ reliance on farmland habitat  

&nbsp;  

### 1.3. Equation components  
#### **$P_t$** - reduced foraging activity potential
$P_t$ is calculated as follows:   
$$P_t = \frac{G_t}{G*H}$$

$G_t$ = total number of generations of the species' given life stage (i.e. $G_{ta}$ for adults, $G_{tl}$ for larvae) active in the activity periods affected  
$G$ = total number of species' life stage life cycle components (i.e. sum of the number of generations in each activity period), 
$H$ = number of habitat components used by the species' life stage  

-----

#### **$F_t$** - reduction in forage plant availability
$F_t$ is calculated as follows:  
$$F_t = \frac{A}{F}$$
$A$ = number of points of coincidence between impact on and species life stage's use of forage plant families  
$F$ = number of points of coincidence between species life stage's habitat use and the location of its forage plants  

-----

#### **$N_t$** - reduced nest site availability (**for bees only**)
$N_t$ is calculated as follows:  
$$N_t = \frac{B}{N * H_n}$$

$B$ = number of points of coincidence between impact on and species use of nest sites  
$N$ = number of nest sites  
$H_n$ = number of habitats used where nest sites are likely to occur  


## 2. Set-up
### 2.1. Load packages
```{r load-packages, message=FALSE, purl=FALSE}

rm(list = ls()) # clear env
library(readxl) # for reading in Excel sheets
library(tidyverse) # for data manipulation

```

## 2.2. Load necessary functions

```riskscore_functions.R``` contains functions used by all risk score scripts. It contains:  

* **check_aligned()** - It is essential to the method used here to ensure that the columns of the management change dataset and species' requirements dataset align before calculating overlap parameters - i.e. parameters that work out the impact of a change on a specific resource for a species. This function checks this, and outputs a warning if the column names of the two inputted datasets are not identical.  

* **NA_to_zero()** - Replaces all NAs in a dataset with zeros.  

``` {r check-alignment}
source("riskscore_functions.R")
```


### 2.3. Determine required risk score calculation (**USER INPUT REQUIRED**)
Determine which risk scores to calculate (bees, butterflies or both), by setting the **input** variable to one of either:  

* "bees"  

* "butterflies"  

* "both"  

The default value is "both".  
``` {r set-input}
input <- "both"

if (input != "bees" & input != "butterflies" & input != "both") {
  stop("input is not set to an accepted value: choose 'bees', 'butterflies' or 'both'")
}
```

### 2.4. Read in and process data  
The required datasets are loaded and all NAs are replaced with 0s. For both bees and butterflies, there are 4 data structures required to calculate risk scores:

* **Species requirements** - contains binary data on species' habitats, activity periods, generations per year (and nesting habitats in the case of bees)

* **Species forage plants** - contains binary data on the plant families each species forages on

* **Forage plant locations** - contains binary data on which habitats each plant family can be found in

* **Farm management strategies** - contains binary data on how each management change affects the species' requirements

In addition, the plant families are alphabetised to ensure the same alignment, which is essential in order to easily cross reference between the forage plant locations and species forage plants datasets.  

Note that the farm management strategies are read in a separate chunk with ```purl = FALSE``` so if the file is sourced, a user can load their own management strategy dataset. It must however, follow the same format as the butt_man_strats / bee_man_strats dataset.  

&nbsp;  

#### For butterflies:
``` {r butt-read-in-data, message=FALSE}
if (input == "butterflies" | input == "both") {
  
  # butterfly requirements matrix data
  butterfly <- read_xlsx("Butterfly_requirements.xlsx", skip = 3)
  
  # forage plant locations
  butt_plant_locs <- read_xlsx("forage_plant_location.xlsx", na = "NA")
  
  # butterfly forage plants
  butterfly_plants <- read_xlsx("butterfly_forage_plants.xlsx")
  
  # replace NAs with 0s in all datasets
  butterfly <- NA_to_zero(butterfly)
  
  butt_plant_locs <- NA_to_zero(butt_plant_locs)
  
  butterfly_plants <- NA_to_zero(butterfly_plants)
  
  # alphabetise plant families in plant_locs and in butterfly_plants (so they align correctly)
  butterfly_plants <- butterfly_plants %>%
    select(species:plants_start, 
         sort(colnames(.[,-ncol(butterfly_plants)])), # sort plant cols alphabetically, not including last (plants_end) col
         plants_end)

  butt_plant_locs <- butt_plant_locs[order(butt_plant_locs$plantfamily),]
}
```

``` {r butt-load-man-strats, purl=FALSE}
if (input == "butterflies" | input == "both") {
  
  # read in farm management strategies
  butt_man_strats <- read_xlsx("change.xlsx", sheet="butterflies")
  
  # replace NAs with 0s
  butt_man_strats <- NA_to_zero(butt_man_strats)
}
```

&nbsp;  

#### For bees:  
``` {r bee-read-in-data, message=FALSE}
if (input == "bees" | input == "both") {

  # bee requirements matrix data
  bee <- read_xlsx("Pollinator_requirements.xlsx") 

  # bee forage plants
  bee_plants <- bee %>%
    select(species, plants_start:plants_end)
  
  # forage plant locations
  bee_plant_locs <- read_xlsx("forage_plant_location.xlsx", na="NA")
  
  # replace NAs with 0s in all datasets
  bee <- NA_to_zero(bee)
  
  bee_plant_locs <- NA_to_zero(bee_plant_locs)
  
  bee_plants <- NA_to_zero(bee_plants)

  # alphabetise plant families in plant_locs and in bee_plants (so they align correctly)
  bee_plants <- bee_plants %>%
    select(species:plants_start, 
         sort(colnames(.[,-ncol(bee_plants)])), # sort plant columns alphabetically, not including last (plants_end) col
         plants_end)

  bee_plant_locs <- bee_plant_locs[order(bee_plant_locs$plantfamily),]
}  
```

``` {r bee-load-man-strats, purl=FALSE}
if (input == "bees" | input == "both") {
  
  # farm management strategies
  bee_man_strats <- read_xlsx("change.xlsx", sheet="bees", skip=1) 
  bee_man_strats <- bee_man_strats[1:6,] # select only butler strategies
  
  # replace NAs with 0s
  bee_man_strats <- NA_to_zero(bee_man_strats)
}
```

&nbsp;  

For bees, the forage plants need subsetting to ensure the same plant families are found in the **forage plant locations** dataset and the **bee forage plants**. Plant families found in **forage plant locations** but not **bee forage plants** are ones that no bee species forages on, whereas those found in **bee forage plants** but not **forage plant locations** are not relevant to the analysis, due to being plant families that aren't found either in farmland or in the UK.

``` {r bee-data-prep}
if (input == "bees" | input == "both") {
  
  # extract plant families for bee_plant_locs and bee_plants
  plant_fams <- bee_plant_locs %>% pull(plantfamily)
  bee_plant_fams <- bee_plants %>% 
    select(plants_start:plants_end, -c(plants_start,plants_end)) %>% 
    colnames(.) 
  
  # find plant families that are in bee_plant_locs but not bee_plants
  not_bee_plants <- 0
  for (plant in plant_fams) {
    if (!(plant %in% bee_plant_fams)) {
      not_bee_plants <- c(not_bee_plants, plant)
    }
  }
  not_bee_plants <- not_bee_plants[-1]
  
  # subset plant family locations to not include plant families bees don't forage on
  for (i in not_bee_plants) {
    bee_plant_locs <- bee_plant_locs %>%
      filter(plantfamily != i)
  }
  
  # find plant families that are in bee_plants but not bee_plant_locs
  not_farm_plants <- 0
  for (plant in bee_plant_fams) {
    if(!(plant %in% plant_fams)) {
      not_farm_plants <- c(not_farm_plants, plant)
    }
  }
  not_farm_plants <- not_farm_plants[-1]
  
  # subset bee forage plants to not include those that aren't relevant (e.g. not on farmland, not present in UK)
  bee_plants <- bee_plants %>%
    select(-all_of(not_farm_plants))
  
  # remove all variables used as they are no longer needed
  rm(bee_plant_fams)
  rm(i)
  rm(not_bee_plants)
  rm(not_farm_plants)
  rm(plant)
  rm(plant_fams)
}
```

## 3. Calculate $P_t$ 
For butterflies, this is $P_{ta}$ for adults, and $P_{tl}$ for larvae. The same is true for all parameters calculated.

### 3.1. Calculate $G$ and $H$
$G$ = total number of species' life cycle components (i.e. sum of the number of generations in each activity period), 
$H$ = number of habitat components used by the species  

$H$ is calculated by summing up the habitat component columns of the species' requirements per species (row). However, the two habitats referring to the cropped area of the farmland - Cropped Arable (CA) and Cropped Grassland (CG) - are combined into a 'cropped area' habitat.  

$G$ is calculated via row (i.e. per species) sums of the generations columns of the requirements dataset. These columns convey the number of generations of the species per year and the activity periods (early, mid or late) in which they lie.  

``` {r calc-G-H}
calc_bee_butt_G_H <- function(data) {
  
  # create output dataframe
  output <- data.frame(H = rep(NA, nrow(data)),
                       G = rep(NA, nrow(data)))
  
  # calculate H
  output[,"H"] <- data %>%
    select(hab_start : hab_end) %>%  # select habitat columns
    select(-c(hab_start, hab_end)) %>%  # remove marker cols
    mutate(Cropped = CA_hab | CG_hab) %>%  # create cropped area col and remove CG and CA
    select(-c(CA_hab, CG_hab)) %>%
    rowSums(.)
  
  # calculate G (select generations col of respective df)
  output[,"G"] <- data %>%
    select(gens_start : gens_end) %>%
    rowSums(.)

  return(output)
}

```

### 3.2. Calculate $G_t$
$G_t$ = number of generations of a species active in the activity periods affected

Here, 'strat' is a single management strategy - i.e. one row of the management strategy data frame.  

In order to calculate $G_t$ , firstly the number of generations in each activity period (i.e. early, mid, late) is calculated for each species. Then, where there's an overlap between species' use of the activity period and effects of the management change on activity periods, the effect is multiplied by the number of generations in the affected activity period(s). These effects are then summed by row (species) to give $G_t$.  

Note that in the calculation of $G_t$, the overlaps of the two crop habitats, cropped arable (CA) and cropped grassland (CG) are combined (using the 'or' function) before the final sum is calculated.  

``` {r calc-Gt}
calc_bee_butt_Gt <- function(data, strat) {
  
  # select activity period cols of management change data
  activity_effects <- strat %>%
    select(activity_start : activity_end) %>%
    select(-c(activity_start, activity_end)) # remove start and end cols
  
  # select activity periods and generation data from species requirements
  activity <- data %>%
    select(activity_start : activity_end) %>%
    select(-c(activity_start, activity_end))
  
  gens_per_period <- data %>%
    select(gens_start : gens_end) %>%
    select(-c(gens_start, gens_end))
  
  # find out the number of generations present in each activity period (early, mid, late)
  early <- gens_per_period %>%
    select(contains("early")) %>%
    rowSums(.)
  mid <- gens_per_period %>%
    select(contains("mid")) %>%
    rowSums(.)
  late <- gens_per_period %>%
    select(contains("late")) %>%
    rowSums(.)
  
  # isolate habs to work out total number of habitats (4 for butterfly, 3 for bee)
  habs <- data %>%
    select(hab_start : hab_end, 
           -c(hab_start, hab_end))
  
  all_gens_per_period <- data.frame(rep(data.frame(early, mid, late), ncol(habs)-1)) # -1 as CA and CG are combined to become 'cropped area'
  
  # Check columns of diets_habs and strat are the same (if not aligned, overlap calculation will not be correct)
  # check requirements and change data columns are aligned (i.e. the same)
  check_aligned(colnames(activity), colnames(activity_effects))
  
  # find overlap between activity periods used and activity periods affected by the management strategy
  overlap <- as.data.frame(t(apply(activity, 1, function(row) row & activity_effects)))
  names(overlap) <- names(activity_effects)
  
  # get index of CA (cropped arable) and CG (cropped grassland) columns in overlap
  overlap_CA_only <- overlap %>% select(contains("CA_"))
  overlap_CG_only <- overlap %>% select(contains("CG_"))
  
  CA_cols <- which(names(overlap) %in% names(overlap_CA_only))
  CG_cols <- which(names(overlap) %in% names(overlap_CG_only))
  
  # combine the CA and CG overlaps into a 'cropped area' overlap
  Cropped <- t(apply(overlap, 1, function(row) row[CA_cols] | row[CG_cols] ))  # 7:9 = CA cols, 10:12 = CG cols
  
  truncated_overlap <- as_tibble(overlap) %>%
    select(-contains(c("CA","CG"))) %>%
    cbind(., Cropped)
  
  # multiply activity period effects by the number of generations in the activity period
  all_gens_affected <- truncated_overlap * all_gens_per_period
  
  # calculate Gts
  Gt <- rowSums(all_gens_affected)
  
  return(Gt)
  
}
```

### 3.3. Calculate Pt

This function calls the relevant functions defined above in order to calculate $P_t$ for all species for a particular management strategy.  
``` {r calc-Pt}
calc_bee_butt_Pt <- function(data, strat) {
  
  G_H <- calc_bee_butt_G_H(data)
  G <- G_H$G
  H <- G_H$H
  
  Gt <- calc_bee_butt_Gt(data, strat)
  
  # CALCULATE Pt
  Pt = Gt / (G * H)
  
  # replace infinite or NA values with 0
  Pt <- 
    ifelse(
      is.nan(Pt) | is.infinite(Pt) == T,  # test
      0, # if yes
      Pt  # if no
    )
  
  return(Pt)
}

```

``` {r test-pt, purl=FALSE}
if (input == "bees") {
  all_species <- bee$species
  dat <- data.frame(species = all_species,
                    Pt = calc_bee_butt_Pt(bee, bee_man_strats[4,]))
  dat
  
  bombus <- dat %>%
      filter(grepl("Bombus", species))
  bombus
}

```

## 4. Calculate $F_t$

### 4.1. Calculate $F$ and $A$
$F$ = points of coincidence between species habitat use and the location of its forage plants  
$A$ = number of points of coincidence between the impact on and species’ use of forage plant families  


Calculating $A$ and $F$ relies on subsetting the plant locations dataset, which has plant families down the rows and the habitats across the columns. If a plant family is found in a habitat, that cell is populated with a 1. Else, it's a 0. $F$ and $A$ are calculated per species in a loop. The first step is subsetting the rows (plant families) of the plant location data to only those the species forages on, as this is required for the calculation of both $A$ and $F$.  

To calculate $F$, this new dataset with only species-specific plant families is subsetted further to only the habitats that the species forages on. After this, the rows (plant families) and columns (habitats) remaining are only those relevant to the species. The presences (all the 1s) are then summed to give $F$, the overlap between species' habitat use and the location of its forage plants. Note that if the species is present in both crop habitats (arable and grassland), these columns are substituted for a combined 'cropped area' column before summing.  

For the calculation of $A$, first the overlap between the forage habitats used by the species and the effect of the management change on these habitats is calculated. This overlap is split into 'general' habitat quality effects and those affecting damp plants specifically. A value for $A$ is calculated for each effect individually, and these are summed to give a final $A$ value. For each individual effect, $A$ is calculated per species in a loop, as for $F$. Similar to $F$, the plant location data subsetted to species-specific plant families (rows) is used, but rather than subsetting to only habitats (columns) used by the species, the dataset is subsetted to only habitats for which there was an overlap - i.e. one that is both affected by the change and used by the species. After this, similar to for $F$, the presences in this subsetted plant locations dataset are summed to give the value for $A$. However, for the damp-plant-specific effects, the plant families (rows) are further subsetted to only families with an affinity for damp conditions before summing.  

There are a couple of extra conditions in the calculation of $A$. Firstly, similar to in the calculation of $F$, if both crop habitats (arable and grassland) are affected, then these columns are substituted for a combined 'cropped area' column. Secondly, the 'cropped area' column is also used if the management change affects both crop habitats, and the species uses at least one of them as well as at least one non-crop habitat. Thirdly, the plant family 'Crops' is removed from the plant locations data for the calculation of $A$, as it's assumed that the crops will not be negatively affected by any management change.  

**About species forage plants:**  

* Butterflies have long tongues and so forage plants don't differ between species. This means adults of all butterfly species have the same set of forage plants. Therefore, $F_a$ ($F$ for adults) will just be the total number of forage plants found in the foraging habitat(s) of each butterfly species.  

* Butterfly larvae (caterpillars) have much more specific plant forage families, as do the bee species.  

``` {r calc-F-A}
calc_bee_butt_A_F <- function(data, plants, plant_locs, strat) {
  
  # pull plant names from plant locations and species' forage plants, to check they are the same
  plant_locs_names <- plant_locs %>% pull(plantfamily)
  plants_names <- colnames(plants %>% 
                             select(plants_start:plants_end) %>% 
                             select(-c(plants_start, plants_end)))
  
  # check plant names are the same, print warning if not
  if (identical(plant_locs_names, plants_names) == F) {
    warning("WARNING: columns of butterfly forage plants are not the same as rows of plant locations data, i.e. plant families are not the same. Calculations may be incorrect.")
    
    print("Cols of butterfly plant data:")
    print(paste(plants_names))
    print(paste("Rows of plant locations data:", plant_locs_names))
  }
  
  # initialise output dataframe
  output <- data.frame(F = rep(NA, nrow(data)),
                       A = rep(NA, nrow(data)))
  
  # select plant species cols from species' forage plants data
  forage_plants <- plants %>% 
    select(plants_start : plants_end) %>%
    select(-c(plants_start, plants_end)) # remove marker cols
  
  
  # subset species' requirements data to habitat and damp cols
  habs <- data %>% 
    select(hab_start:hab_end, damp_start:damp_end)
  
  # select habitat + damp cols of change data
  hab_effects <- strat %>%
    select(hab_start:hab_end, damp_start:damp_end)
  
  # check species requirements ("habs") and change data ("hab_effects") columns are aligned (i.e. the same)
  check_aligned(colnames(habs), colnames(hab_effects))
  
  # find overlap between species habitat use and effects on habitat
  overlap <- as.data.frame(t(apply(habs, 1, function(row) row & hab_effects)))
  colnames(overlap) <- colnames(habs)
  
  # split effects on species into general and damp effects
  general_effects <- overlap %>% 
    select(hab_start : hab_end) %>%
    select(-c(hab_start, hab_end))  # remove marker cols
  
  damp_effects <- overlap %>% 
    select(damp_start : damp_end) %>%
    select(-c(damp_start, damp_end))  # remove marker cols
  
  
  # calculate A and F for each species
  for(species in 1:nrow(habs)) {
    
    sp_general_effects <- general_effects[species,]
    sp_damp_effects <- damp_effects[species,]
    
    # subset rows of plant locs to only include plants the species forages on
    sp_plant_locs <- plant_locs[which(forage_plants[species,] == 1),]

    # for use in calculation of A:
    # create version without 'crops' (row) forage plant, as it won't be negatively affected by any management change
    if ("Crops" %in% sp_plant_locs$plantfamily) {

      no_crop_sp_plant_locs <- sp_plant_locs[sp_plant_locs$plantfamily != "Crops",]
    } 
    else {
      no_crop_sp_plant_locs <- sp_plant_locs
    }
      
    # if species has no forage plants, print warning and set A and F to 0
    if (nrow(sp_plant_locs) == 0) { 
      warning(paste("WARNING: Species", species, "has 0 forage plants. Al = 0"))
      
      output[species, "A"] <- 0
      output[species, "F"] <- 0
      next  # go to next iteration of for loop
    }
    
    # CALCULATE F
    
    # subset habitat to current species
    sp_habs <- habs %>%
      select(hab_start : hab_end) %>%
      select(-c(hab_start, hab_end))
    sp_habs <- sp_habs[species,]
    
    # remove 'cropped area' (CA) habitat + species names cols so the sp_plant_loc cols align with sp_habs (species habitat)
    subsetted_plant_locs <- sp_plant_locs %>%
      select(-c(croppedarea, plantfamily))

    
    # subset sp_plant_locs to only habitats occupied by the species
    all_forage_plants <- subsetted_plant_locs[,which(sp_habs != 0)]
    
    # if both grass and arable fields are selected (are part of species habitat), then remove them and replace with 'croppedarea' col
    if (has_name(all_forage_plants, "grassfields") && has_name(all_forage_plants, "arablefields")) {
      all_forage_plants <- all_forage_plants %>%
        select(-c(grassfields, arablefields)) %>%
        cbind(., sp_plant_locs$croppedarea)
    }
    output[species, "F"] <- sum(all_forage_plants)
    
    # CALCULATE A
    
    # group the general and damp habitat effects
    sp_effects <- list(sp_general_effects, sp_damp_effects)
    plants_affected <- c(NA, NA)
    
    # remove species name col from no_crop_sp_plant_locs (so cols align with the hab effects)
    no_crop_sp_plant_locs <- no_crop_sp_plant_locs %>%
      select(-plantfamily)
    
    for (effect in 1:length(sp_effects)) {

      # subset plant locations to only habitats where there was an overlap between species use and strategy impact
      plant_locs_affected <- no_crop_sp_plant_locs[,which(sp_effects[[effect]] != 0)]
      
      #plant_locs_affected <- sweep(no_crop_sp_plant_locs, 2, sp_effects[[effect]], FUN = "*")
      
      if (ncol(plant_locs_affected) == 0) {
        
        plants_affected[effect] <- 0
        next  # if no plants affected, skip to next iteration (next effect)
      }
      
      # if both grass and arable fields are affected, then remove them and replace with 'croppedarea' col
      if (has_name(plant_locs_affected, "grassfields") && has_name(plant_locs_affected, "arablefields")) {
        plant_locs_affected <- plant_locs_affected %>%
          select(-c(grassfields, arablefields)) %>%
          cbind(., no_crop_sp_plant_locs$croppedarea)
      } 
      else if (hab_effects$CG_hab != 0 & hab_effects$CA_hab != 0){ #  if strat affects all crops 
        if (sum(has_name(plant_locs_affected, c("grassfields", "arablefields"))) > 0) { # if sp is on at least 1 crop

          if (sum(sp_habs) > 1) { # if sp is also on at least 1 other hab

            plant_locs_affected <- plant_locs_affected %>% # do same as above - used cropped area col
              select(-contains(c("grassfields", "arablefields"))) %>%
              cbind(., no_crop_sp_plant_locs$croppedarea)
          }
        }
      }
      

      if (effect == 2) {  # if damp effects, need to subset to only damp plants
        damp_plants_affected <- plant_locs_affected[no_crop_sp_plant_locs$likesdamp == "yes",]
        
        plants_affected[effect] <- sum(damp_plants_affected)
      }
      else {
        plants_affected[effect] <- sum(plant_locs_affected)
      }
      
    }
    # sum plants affected by general and damp effects to get total effects
    total_plants_affected <- sum(plants_affected)
    
    output[species, "A"] <- total_plants_affected
  }
  
  return(output)
}

```

``` {r test-f-a, purl=FALSE}
if (input == "bees") {

  dat <- data.frame(species = all_species,  
                    calc_bee_butt_A_F(bee, bee_plants, bee_plant_locs, bee_man_strats[6,]))
  dat

}


```


### 4.2. Calculate $F_t$

This function calls the relevant functions defined above, in order to calculate $F_t$ for all species for a particular management change.  
``` {r calc-Ft}
calc_bee_butt_Ft <- function(data, plants, plant_locs, strat) {
  
  A_F <- calc_bee_butt_A_F(data, plants, plant_locs, strat)
  A <- A_F$A
  F <- A_F$F
  
  # CALCULATE Ft
  Ft <- A / F
  
  # replace infinite or NA values with 0
  Ft <- 
    ifelse(
      is.nan(Ft) | is.infinite(Ft) == T,  # test
      0, # if yes
      Ft  # if no
    )
  
  return(Ft)
}

```

``` {r tet-ft, purl=FALSE}
if (input == "bees") {
  out <- data.frame(species = all_species,
                  Ft = calc_bee_butt_Ft(bee, bee_plants, bee_plant_locs, bee_man_strats[4,]))

bombus <- out %>%
  filter(grepl("Bombus", species))
bombus
}

```

## 5. Calculate $N_t$ (for bees only)

$N_t$ = risk score associated with reduced nesting site availability  

$$N_t = \frac{B}{(N * H_n)}$$
where  
$B$  = number of points of coincidence between the impact on and species' use of nest sites  
$N$  = number of nest sites used  
$H_n$ = number of habitats used where nest sites are likely to occur  

### 5.1. Calculate $N$ and $H_n$

For calculation of $N$ and $H_n$, rather than calculating them separately, $N * H_n$ (the denominator of $N_t$) is calculated. This is due to how the data is structured - the possible nest sites are recorded per the habitats they are present in, so a simple row sum of the nesting data gives $N * H_n$, which is the number of nest sites used, summed across all the habitats used where the nest sites occur.  

``` {r calc-N-Hn}
calc_bee_N_Hn <- function(data) {
  
  # calculate H times N
  N_times_Hn <- data %>%
    select(nest_start : nest_end,
           -c(nest_start, nest_end)) %>%
    rowSums(.)
  
  return(N_times_Hn)
}
```

### 5.2. Calculate $B$  

$B$ is the overlap between effects on and species' use of nest sites, which is calculated using the '&' operator: returning true only if the species uses the nest site and its affected by the management change. This is applied row-wise (i.e. per species) to the species requirements data, and then summed row-wise to give the total overlap per species, $B$.  

``` {r calc-b}
calc_bee_B <- function(data, strat) {
  
  # extract nesting data from species' requirements and change data
  nesting <- data %>% 
    select(nest_start : nest_end) %>%
    select(-c(nest_start, nest_end))
  
  nesting_effects <- strat %>%
    select(nest_start : nest_end) %>%
    select(-c(nest_start, nest_end))
  
  # check requirements and change data columns are aligned (i.e. the same)
  check_aligned(colnames(nesting), colnames(nesting_effects))
  
  # calculate overlap between nesting requirements and effects
  overlap <- as.data.frame(t(apply(nesting, 1, function(row) row & nesting_effects)))
  
  # calculate B
  B <- rowSums(overlap)
  
  return(B)
}
```

### 5.3. Calculate $N_t$
$$N_t = \frac{B}{N * H_n}$$

This function calculates $N_t$, using the relevant equations defined above, for all species for a specific management change.  

``` {r calc-Nt}
calc_bee_Nt <- function(data, strat) {
  
  N_times_Hn <- calc_bee_N_Hn(data)

  B <- calc_bee_B(data, strat)

  # CALCULATE Nt
  Nt <- B / N_times_Hn

  # replace infinite or NA values with 0
  Nt <- 
    ifelse(
      is.nan(Nt) | is.infinite(Nt) == T,  # test
      0, # if yes
      Nt  # if no
    )
  
  return(Nt)
}
```

## 6. Calculate risk score

### 6.1. Butterflies

&nbsp;  

#### Function to create separate adult and larval datasets
For butterflies, each risk score variable needs to be calculated twice - once for larvae and once for adults. The below function can split the **butterfly forage plants** and **butterfly requirements** datasets into separate datasets for each life stage (adults + larvae).  

``` {r butt-sep-a-l}
separate_lifestages <- function(data) {
  
  ## Function to create separate datasets for adults and larvae
  
  if ("lifestage" %in% colnames(data)) {  # this is the case for the butterfly forage plants matrix
    adults <- data[data$lifestage == "a",]
    larvae <- data[data$lifestage == "l",]
  }
  else {  # for the butterfly requirements matrix
    adults <- data %>%
    select(contains("Ad_"))
    
    # rename cols to   not include "Ad_"
    colnames(adults) <- gsub(pattern = "Ad_", replacement = "", colnames(adults)) 

    larvae <- data %>%
    select(contains("L_"))
    
    # rename cols to not include "L_"
    colnames(larvae) <- gsub(pattern = "L_", replacement = "", colnames(larvae))  
  }
  
  return(list(adults, larvae))
}
```

&nbsp;  

#### Function to calculate risk scores

This function, unlike the functions defined up to this point, can take multiple management strategies and outputs risk scores for each butterfly species for each strategy. It also (in the case that multiple strategies are inputted) calculates a **total risk score**, by summing the risk scores across all management strategies for each species.  

``` {r butt-calc-riskscore}
calc_butterfly_riskscore <- function(data, plants, plant_locs, strategies) {
  
  # initialise riskscores dataframe, rows are species, cols are strategies
  riskscores <- data.frame(matrix(NA, 
                                  nrow = nrow(data), 
                                  ncol = nrow(strategies) + 1)) # +1 to add in species names
  # put species names in first col
  riskscores[,1] <- data[,1]
  
  # name columns of riskscores according to strategies
  strat_names <- strategies %>% pull(agric_change)
  colnames(riskscores) <- c("species", strat_names)
  
  # extract reliance (R) values for adults and larvae from butterfly data
  R <- data %>% 
    select(contains("reliance"))
  Ra <- R %>%
    select(contains("Ad_"))
  Rl <- R %>%
    select(contains("L_"))
  
  # CALCULATE RISK SCORES per strategy and store in riskscores dataframe
  for (strat in 1:nrow(strategies)) {
    
    # separate adults and larval stages for both butterfly and plants data
    butterfly_data <- separate_lifestages(data)
    adult_data <- butterfly_data[[1]]
    larval_data <- butterfly_data[[2]]
    
    plants_data <- separate_lifestages(plants)
    adult_plants <- plants_data[[1]]
    larval_plants <- plants_data[[2]]
    
    # CALCULATE PT AND FT for both adults and larvae
    Pta <- calc_bee_butt_Pt(adult_data, strategies[strat,])
    Ptl <- calc_bee_butt_Pt(larval_data, strategies[strat,])
    
    Fta <- calc_bee_butt_Ft(adult_data, adult_plants, plant_locs, strategies[strat,])
    Ftl <- calc_bee_butt_Ft(larval_data, larval_plants, plant_locs, strategies[strat,])
    
    # CALCULATE RISK SCORE
    riskscores[,strat+1] <- ((Pta + Fta) / Ra) + ((Ptl + Ftl) / Rl)
  }
  
  # calculate total risk for each species by summing risk across all strategies (if more than one strategy)
  if (nrow(strategies) > 1) {
    riskscores$total_risk <- rowSums(riskscores[,-1])
  }
  
  return(riskscores)
}
  
```

&nbsp;  

#### Function to calculate standardised risk scores

In order to allow cross-taxonomic comparison of risk scores, they must be standardised. This is done by dividing the risk scores by the number of key resource requirements in the framework. This is equivalent to the number of overlap parameters - i.e. parameters that work out the impact of a change on a specific resource for a species. For butterflies, this number is 4, as there are 4 such parameters (2 for adults and 2 for larvae): $G_{ta}$, $G_{tl}$, $A_a$ and $A_l$. See equations in Section 1 for more details.  

If only comparing risk scores within the taxon, this standardisation step is not required, and the ```calc_butterfly_riskscore()``` function can be used instead.  

``` {r calc-standardised-riskscore}
calc_std_butterfly_riskscore <- function(data, plants, plant_locs, strategies) {
  
  # set number of resource requirements used by the taxa
  num_resource_reqs <- 3
  
  # calculate non-standardised risk scores
  risk_scores <- calc_butterfly_riskscore(data, plants, plant_locs, strategies)
  
  # divide all risk scores by number of resource requirements (minus the species name column)
  std_risk_scores <- risk_scores[,-1] / num_resource_reqs
  std_risk_scores <- cbind(risk_scores$species, std_risk_scores) # add back species name column
  names(std_risk_scores)[1] <- "species"
  
  return(std_risk_scores)
}

std <- calc_std_butterfly_riskscore(butterfly, butterfly_plants, butt_plant_locs, butt_man_strats)
```

&nbsp;

#### Calculate risk scores
Test scores against Butler's risk scores to ensure method is correct.
``` {r butt-test-riskscore, purl=FALSE}
if (input == "butterflies" | input == "both") {
 
  butt_risk <- calc_butterfly_riskscore(butterfly, butterfly_plants, butt_plant_locs, butt_man_strats)
  butt_risk
  # 
  # risk$species_latin <- c("Gonepteryx_rhamni", "Thecla_betulae", "Polygonum_c_album", "Polyommatus_icarus", "Thymelicus_lineola", 
  #                         "Pyronia_tithonus", "Pieris_napi", "Celastrina_argiolus", "Ochlodes_sylvanus", "Pieris_brassicae",
  #                         "Melanargia_galathea", "Euphydryas_aurina", "Maniola_jurtina", "Anthocharis_cardamines", "Aglais_io", 
  #                         "Aphantopus_hyperantus", "Lycaena_phlaeas", "Coenonympha_pamphilus", "Thymelicus_sylvestris", "Aglais_urticae",
  #                         "Pieris_rapae", "Pararge_aegeria", "Lasiommata_megera", "Satyrium_w_album")
  # 
  # risk_sorted <- risk[order(risk$species_latin),]
  butt_butler_risk <- c(2.19, 1.65, 3.81, 2.01, 1.42, 1.44, 2.10, 3.53, 1.67, 2.18, 3.03, 1.85, 2.02, 1.85, 2.10, 1.56, 2.34, 1.86, 1.65, 1.06, 2.42, 2.15, 2.10, 2.10)
  butt_butler_species <- c(
      "small_tortoiseshell",
      "orange_tip",
      "ringlet",
      "green-veined_white",
      "small_white",
      "holly_blue",
      "small_heath",
      "marsh_fritillary",
      "brimstone",
      "peacock",
      "wall_brown",
      "small_copper",
      "meadow_brown",
      "marbled_white",
      "large_skipper",
      "speckled_wood",
      "large_white",
      "comma",
      "common_blue",
      "gatekeeper",
      "white-letter_hairstreak",
      "brown_hairstreak",
      "essex_skipper",
      "small_skipper"
  )
  butt_butler_data <- data.frame(butler_species = butt_butler_species, butler_risk = butt_butler_risk)
  butt_butler_sorted <- butt_butler_data[order(butt_butler_data$butler_species),]
  
  butt_butler_sorted$my_risk <- round(butt_risk$total_risk, 2)
  butt_butler_sorted$same <- butt_butler_sorted$butler_risk == butt_butler_sorted$my_risk
  butt_butler_sorted$diff <- butt_butler_sorted$butler_risk - butt_butler_sorted$my_risk
  butt_butler_sorted
}
```

### 6.2. Bees

#### Function to calculate risk scores

This function, like the butterfly risk score function above, can take multiple management strategies and outputs risk scores for each bee species for each strategy. It also (in the case that multiple strategies are inputted) calculates a **total risk score**, by summing the risk scores across all management strategies for each species.  

``` {r bee-calc-riskscore}
calc_bee_riskscore <- function(data, plants, plant_locs, strategies) {
  
  # initialise riskscores dataframe, rows are species, cols are strategies
  riskscores <- data.frame(matrix(NA, 
                                  nrow = nrow(data), 
                                  ncol = nrow(strategies) + 1)) # +1 to add in species names
  # put species names in first col
  riskscores[,1] <- data[,1]
  
  # name columns of riskscores according to strategies
  strat_names <- strategies %>% pull(agric_change)
  colnames(riskscores) <- c("species", strat_names)
  
  # extract reliance (R) values for adults and larvae from butterfly data
  R <- data %>% 
    select(contains("reliance"))
  
  # CALCULATE RISK SCORES per strategy and store in riskscores dataframe
  for (strat in 1:nrow(strategies)) {
    
    # CALCULATE PT, FT AND NT
    Pt <- calc_bee_butt_Pt(data, strategies[strat,])
    Ft <- calc_bee_butt_Ft(data, plants, plant_locs, strategies[strat,])
    Nt <- calc_bee_Nt(data, strategies[strat,])

    # CALCULATE RISK SCORE
    riskscores[,strat+1] <- (Pt + Ft + Nt) / R
  }

  # calculate total risk for each species by summing risk across all strategies (if more than one strategy)
  if (nrow(strategies) > 1) {
    riskscores$total_risk <- rowSums(riskscores[,-1])
  }
  
  return(riskscores)
}
```

&nbsp;  

#### Function to calculate standardised risk scores

Like for butterflies, in order to allow cross-taxonomic comparison of risk scores, they must be standardised. This is done by dividing the risk scores by the number of key resource requirements in the framework. This is equivalent to the number of overlap parameters - i.e. parameters that work out the impact of a change on a specific resource for a species. For bees, this number is 3, as there are 3 such parameters: $G_t$, $A$ and $B$. See equations in Section 1 for more details.  

If only comparing risk scores within the taxon, this standardisation step is not required, and the ```calc_bee_riskscore()``` function can be used instead.  

``` {r calc-standardised-riskscore}
calc_std_bee_riskscore <- function(data, plants, plant_locs, strategies) {
  
  # set number of resource requirements used by the taxa
  num_resource_reqs <- 3
  
  # calculate non-standardised risk scores
  risk_scores <- calc_bee_riskscore(data, plants, plant_locs, strategies)
  
  # divide all risk scores by number of resource requirements (minus the species name column)
  std_risk_scores <- risk_scores[,-1] / num_resource_reqs
  std_risk_scores <- cbind(risk_scores$species, std_risk_scores) # add back species name column
  names(std_risk_scores)[1] <- "species"
  
  return(std_risk_scores)
}
```



&nbsp; 

#### Calculate risk scores
``` {r bee-run-risk, purl=FALSE}
if (input == "bees" | input == "both") {
  
  bee_risk <- calc_bee_riskscore(bee, bee_plants, bee_plant_locs, bee_man_strats)

  # bombus <- bee_risk %>%
  #   filter(grepl("Bombus", species))
  # bombus
  
  #bee_butler_risk <- c(2.06,0.80,2.21,0.94,0.75,0.77,2.36,1.25,0.73,2.38,1.29,1.40,4.23,0.78)
  
  bee_butler_risk <- read_xlsx("Butler_validation/Pollinator risk assessment database.xlsx", 9)
  
  bee_butler <- data.frame(species = bee_butler_risk$Species,
                       butler_risk = round(bee_butler_risk$score, 2),
                       my_risk = round(bee_risk$total_risk, 2))
  bee_butler$same <- bee_butler$butler_risk == bee_butler$my_risk
  bee_butler$diff <- bee_butler$butler_risk - bee_butler$my_risk
  bee_butler
  
  print(paste("correct species =", nrow(bee_butler[bee_butler$same == T,]), "/", nrow(bee_butler)))
}
```